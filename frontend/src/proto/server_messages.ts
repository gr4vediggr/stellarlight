// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.31.1
// source: server_messages.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { GalaxyGenerateSettings } from "./client_commands";

export const protobufPackage = "messages";

/** Main message wrapper from server */
export interface ServerMessage {
  /** Optional response ID */
  messageId: string;
  timestamp: number;
  /** Lobby Messages */
  lobbyMessage?:
    | LobbyMessage
    | undefined;
  /** Game Messages */
  gameMessage?:
    | GameMessage
    | undefined;
  /** Chat Messages */
  chatMessage?:
    | ChatMessage
    | undefined;
  /** System Messages */
  systemMessage?:
    | SystemMessage
    | undefined;
  /** Error Messages */
  errorMessage?: ErrorMessage | undefined;
}

export interface LobbyMessage {
  lobbyState?: LobbyStateMessage | undefined;
  playerJoined?: PlayerJoinedMessage | undefined;
  playerLeft?: PlayerLeftMessage | undefined;
  playerUpdated?: PlayerUpdatedMessage | undefined;
  settingsUpdated?: LobbySettingsUpdatedMessage | undefined;
  gameStarting?: GameStartingMessage | undefined;
  gameLoading?: GameLoadingMessage | undefined;
}

/** Complete lobby state - sent when player joins or significant changes occur */
export interface LobbyStateMessage {
  sessionId: string;
  inviteCode: string;
  hostPlayerId: string;
  status: LobbyStateMessage_LobbyStatus;
  players: LobbyPlayer[];
  settings: GalaxyGenerateSettings | undefined;
}

export enum LobbyStateMessage_LobbyStatus {
  WAITING = 0,
  STARTING = 1,
  IN_GAME = 2,
  UNRECOGNIZED = -1,
}

export function lobbyStateMessage_LobbyStatusFromJSON(object: any): LobbyStateMessage_LobbyStatus {
  switch (object) {
    case 0:
    case "WAITING":
      return LobbyStateMessage_LobbyStatus.WAITING;
    case 1:
    case "STARTING":
      return LobbyStateMessage_LobbyStatus.STARTING;
    case 2:
    case "IN_GAME":
      return LobbyStateMessage_LobbyStatus.IN_GAME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LobbyStateMessage_LobbyStatus.UNRECOGNIZED;
  }
}

export function lobbyStateMessage_LobbyStatusToJSON(object: LobbyStateMessage_LobbyStatus): string {
  switch (object) {
    case LobbyStateMessage_LobbyStatus.WAITING:
      return "WAITING";
    case LobbyStateMessage_LobbyStatus.STARTING:
      return "STARTING";
    case LobbyStateMessage_LobbyStatus.IN_GAME:
      return "IN_GAME";
    case LobbyStateMessage_LobbyStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LobbyPlayer {
  playerId: string;
  displayName: string;
  color: string;
  isReady: boolean;
  isHost: boolean;
  isConnected: boolean;
  joinedAt: number;
}

/** Individual update messages for efficiency */
export interface PlayerJoinedMessage {
  player: LobbyPlayer | undefined;
}

export interface PlayerLeftMessage {
  playerId: string;
  displayName: string;
}

export interface PlayerUpdatedMessage {
  player: LobbyPlayer | undefined;
}

export interface LobbySettingsUpdatedMessage {
  settings: GalaxyGenerateSettings | undefined;
  updatedByPlayerId: string;
}

export interface GameStartingMessage {
  finalSettings: GalaxyGenerateSettings | undefined;
  startTime: number;
}

export interface GameLoadingMessage {
  /** 0.0 to 1.0 */
  progress: number;
  /** "Generating galaxy...", "Creating empires...", etc. */
  statusText: string;
  /** "GALAXY_GENERATION", "EMPIRE_SETUP", etc. */
  phase: string;
}

export interface GameMessage {
  gameState?: GameStateMessage | undefined;
  gameEvent?: GameEventMessage | undefined;
  turnUpdate?: TurnUpdateMessage | undefined;
}

export interface GameStateMessage {
  /** Full or partial game state */
  stateData: string;
  turnNumber: number;
  gameTime: number;
}

export interface GameEventMessage {
  /** "FLEET_ARRIVED", "BATTLE_OCCURRED", etc. */
  eventType: string;
  /** JSON event data */
  eventData: string;
  affectedPlayers: string[];
}

export interface TurnUpdateMessage {
  turnNumber: number;
  turnDeadline: number;
  isPaused: boolean;
}

export interface ChatMessage {
  senderId: string;
  senderDisplayName: string;
  timestamp: number;
  global?: GlobalChatMessage | undefined;
  private?: PrivateChatMessage | undefined;
  lobby?: LobbyChatMessage | undefined;
  system?: SystemChatMessage | undefined;
}

export interface GlobalChatMessage {
  message: string;
}

export interface PrivateChatMessage {
  recipientId: string;
  message: string;
}

export interface LobbyChatMessage {
  message: string;
}

export interface SystemChatMessage {
  message: string;
  /** "INFO", "WARNING", "ERROR" */
  messageType: string;
}

export interface SystemMessage {
  connection?: ConnectionMessage | undefined;
  auth?: AuthMessage | undefined;
  serverStatus?: ServerStatusMessage | undefined;
}

export interface ConnectionMessage {
  /** "CONNECTED", "RECONNECTING", "DISCONNECTED" */
  status: string;
  reason: string;
}

export interface AuthMessage {
  /** "AUTHENTICATED", "TOKEN_EXPIRED", "INVALID_TOKEN" */
  status: string;
  message: string;
}

export interface ServerStatusMessage {
  isMaintenance: boolean;
  version: string;
  playerCount: number;
}

export interface ErrorMessage {
  /** "LOBBY_FULL", "INVALID_COMMAND", etc. */
  errorCode: string;
  errorMessage: string;
  /** Additional context for debugging */
  context: string;
  /** Detailed error information */
  details: string[];
}

function createBaseServerMessage(): ServerMessage {
  return {
    messageId: "",
    timestamp: 0,
    lobbyMessage: undefined,
    gameMessage: undefined,
    chatMessage: undefined,
    systemMessage: undefined,
    errorMessage: undefined,
  };
}

export const ServerMessage: MessageFns<ServerMessage> = {
  encode(message: ServerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message.lobbyMessage !== undefined) {
      LobbyMessage.encode(message.lobbyMessage, writer.uint32(82).fork()).join();
    }
    if (message.gameMessage !== undefined) {
      GameMessage.encode(message.gameMessage, writer.uint32(162).fork()).join();
    }
    if (message.chatMessage !== undefined) {
      ChatMessage.encode(message.chatMessage, writer.uint32(242).fork()).join();
    }
    if (message.systemMessage !== undefined) {
      SystemMessage.encode(message.systemMessage, writer.uint32(322).fork()).join();
    }
    if (message.errorMessage !== undefined) {
      ErrorMessage.encode(message.errorMessage, writer.uint32(402).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.lobbyMessage = LobbyMessage.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.gameMessage = GameMessage.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.chatMessage = ChatMessage.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.systemMessage = SystemMessage.decode(reader, reader.uint32());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.errorMessage = ErrorMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMessage {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      lobbyMessage: isSet(object.lobbyMessage) ? LobbyMessage.fromJSON(object.lobbyMessage) : undefined,
      gameMessage: isSet(object.gameMessage) ? GameMessage.fromJSON(object.gameMessage) : undefined,
      chatMessage: isSet(object.chatMessage) ? ChatMessage.fromJSON(object.chatMessage) : undefined,
      systemMessage: isSet(object.systemMessage) ? SystemMessage.fromJSON(object.systemMessage) : undefined,
      errorMessage: isSet(object.errorMessage) ? ErrorMessage.fromJSON(object.errorMessage) : undefined,
    };
  },

  toJSON(message: ServerMessage): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.lobbyMessage !== undefined) {
      obj.lobbyMessage = LobbyMessage.toJSON(message.lobbyMessage);
    }
    if (message.gameMessage !== undefined) {
      obj.gameMessage = GameMessage.toJSON(message.gameMessage);
    }
    if (message.chatMessage !== undefined) {
      obj.chatMessage = ChatMessage.toJSON(message.chatMessage);
    }
    if (message.systemMessage !== undefined) {
      obj.systemMessage = SystemMessage.toJSON(message.systemMessage);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = ErrorMessage.toJSON(message.errorMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMessage>, I>>(base?: I): ServerMessage {
    return ServerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMessage>, I>>(object: I): ServerMessage {
    const message = createBaseServerMessage();
    message.messageId = object.messageId ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.lobbyMessage = (object.lobbyMessage !== undefined && object.lobbyMessage !== null)
      ? LobbyMessage.fromPartial(object.lobbyMessage)
      : undefined;
    message.gameMessage = (object.gameMessage !== undefined && object.gameMessage !== null)
      ? GameMessage.fromPartial(object.gameMessage)
      : undefined;
    message.chatMessage = (object.chatMessage !== undefined && object.chatMessage !== null)
      ? ChatMessage.fromPartial(object.chatMessage)
      : undefined;
    message.systemMessage = (object.systemMessage !== undefined && object.systemMessage !== null)
      ? SystemMessage.fromPartial(object.systemMessage)
      : undefined;
    message.errorMessage = (object.errorMessage !== undefined && object.errorMessage !== null)
      ? ErrorMessage.fromPartial(object.errorMessage)
      : undefined;
    return message;
  },
};

function createBaseLobbyMessage(): LobbyMessage {
  return {
    lobbyState: undefined,
    playerJoined: undefined,
    playerLeft: undefined,
    playerUpdated: undefined,
    settingsUpdated: undefined,
    gameStarting: undefined,
    gameLoading: undefined,
  };
}

export const LobbyMessage: MessageFns<LobbyMessage> = {
  encode(message: LobbyMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lobbyState !== undefined) {
      LobbyStateMessage.encode(message.lobbyState, writer.uint32(10).fork()).join();
    }
    if (message.playerJoined !== undefined) {
      PlayerJoinedMessage.encode(message.playerJoined, writer.uint32(18).fork()).join();
    }
    if (message.playerLeft !== undefined) {
      PlayerLeftMessage.encode(message.playerLeft, writer.uint32(26).fork()).join();
    }
    if (message.playerUpdated !== undefined) {
      PlayerUpdatedMessage.encode(message.playerUpdated, writer.uint32(34).fork()).join();
    }
    if (message.settingsUpdated !== undefined) {
      LobbySettingsUpdatedMessage.encode(message.settingsUpdated, writer.uint32(42).fork()).join();
    }
    if (message.gameStarting !== undefined) {
      GameStartingMessage.encode(message.gameStarting, writer.uint32(50).fork()).join();
    }
    if (message.gameLoading !== undefined) {
      GameLoadingMessage.encode(message.gameLoading, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LobbyMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLobbyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lobbyState = LobbyStateMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerJoined = PlayerJoinedMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerLeft = PlayerLeftMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.playerUpdated = PlayerUpdatedMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.settingsUpdated = LobbySettingsUpdatedMessage.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gameStarting = GameStartingMessage.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gameLoading = GameLoadingMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LobbyMessage {
    return {
      lobbyState: isSet(object.lobbyState) ? LobbyStateMessage.fromJSON(object.lobbyState) : undefined,
      playerJoined: isSet(object.playerJoined) ? PlayerJoinedMessage.fromJSON(object.playerJoined) : undefined,
      playerLeft: isSet(object.playerLeft) ? PlayerLeftMessage.fromJSON(object.playerLeft) : undefined,
      playerUpdated: isSet(object.playerUpdated) ? PlayerUpdatedMessage.fromJSON(object.playerUpdated) : undefined,
      settingsUpdated: isSet(object.settingsUpdated)
        ? LobbySettingsUpdatedMessage.fromJSON(object.settingsUpdated)
        : undefined,
      gameStarting: isSet(object.gameStarting) ? GameStartingMessage.fromJSON(object.gameStarting) : undefined,
      gameLoading: isSet(object.gameLoading) ? GameLoadingMessage.fromJSON(object.gameLoading) : undefined,
    };
  },

  toJSON(message: LobbyMessage): unknown {
    const obj: any = {};
    if (message.lobbyState !== undefined) {
      obj.lobbyState = LobbyStateMessage.toJSON(message.lobbyState);
    }
    if (message.playerJoined !== undefined) {
      obj.playerJoined = PlayerJoinedMessage.toJSON(message.playerJoined);
    }
    if (message.playerLeft !== undefined) {
      obj.playerLeft = PlayerLeftMessage.toJSON(message.playerLeft);
    }
    if (message.playerUpdated !== undefined) {
      obj.playerUpdated = PlayerUpdatedMessage.toJSON(message.playerUpdated);
    }
    if (message.settingsUpdated !== undefined) {
      obj.settingsUpdated = LobbySettingsUpdatedMessage.toJSON(message.settingsUpdated);
    }
    if (message.gameStarting !== undefined) {
      obj.gameStarting = GameStartingMessage.toJSON(message.gameStarting);
    }
    if (message.gameLoading !== undefined) {
      obj.gameLoading = GameLoadingMessage.toJSON(message.gameLoading);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LobbyMessage>, I>>(base?: I): LobbyMessage {
    return LobbyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LobbyMessage>, I>>(object: I): LobbyMessage {
    const message = createBaseLobbyMessage();
    message.lobbyState = (object.lobbyState !== undefined && object.lobbyState !== null)
      ? LobbyStateMessage.fromPartial(object.lobbyState)
      : undefined;
    message.playerJoined = (object.playerJoined !== undefined && object.playerJoined !== null)
      ? PlayerJoinedMessage.fromPartial(object.playerJoined)
      : undefined;
    message.playerLeft = (object.playerLeft !== undefined && object.playerLeft !== null)
      ? PlayerLeftMessage.fromPartial(object.playerLeft)
      : undefined;
    message.playerUpdated = (object.playerUpdated !== undefined && object.playerUpdated !== null)
      ? PlayerUpdatedMessage.fromPartial(object.playerUpdated)
      : undefined;
    message.settingsUpdated = (object.settingsUpdated !== undefined && object.settingsUpdated !== null)
      ? LobbySettingsUpdatedMessage.fromPartial(object.settingsUpdated)
      : undefined;
    message.gameStarting = (object.gameStarting !== undefined && object.gameStarting !== null)
      ? GameStartingMessage.fromPartial(object.gameStarting)
      : undefined;
    message.gameLoading = (object.gameLoading !== undefined && object.gameLoading !== null)
      ? GameLoadingMessage.fromPartial(object.gameLoading)
      : undefined;
    return message;
  },
};

function createBaseLobbyStateMessage(): LobbyStateMessage {
  return { sessionId: "", inviteCode: "", hostPlayerId: "", status: 0, players: [], settings: undefined };
}

export const LobbyStateMessage: MessageFns<LobbyStateMessage> = {
  encode(message: LobbyStateMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.inviteCode !== "") {
      writer.uint32(18).string(message.inviteCode);
    }
    if (message.hostPlayerId !== "") {
      writer.uint32(26).string(message.hostPlayerId);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    for (const v of message.players) {
      LobbyPlayer.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.settings !== undefined) {
      GalaxyGenerateSettings.encode(message.settings, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LobbyStateMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLobbyStateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inviteCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hostPlayerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.players.push(LobbyPlayer.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.settings = GalaxyGenerateSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LobbyStateMessage {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      inviteCode: isSet(object.inviteCode) ? globalThis.String(object.inviteCode) : "",
      hostPlayerId: isSet(object.hostPlayerId) ? globalThis.String(object.hostPlayerId) : "",
      status: isSet(object.status) ? lobbyStateMessage_LobbyStatusFromJSON(object.status) : 0,
      players: globalThis.Array.isArray(object?.players) ? object.players.map((e: any) => LobbyPlayer.fromJSON(e)) : [],
      settings: isSet(object.settings) ? GalaxyGenerateSettings.fromJSON(object.settings) : undefined,
    };
  },

  toJSON(message: LobbyStateMessage): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.inviteCode !== "") {
      obj.inviteCode = message.inviteCode;
    }
    if (message.hostPlayerId !== "") {
      obj.hostPlayerId = message.hostPlayerId;
    }
    if (message.status !== 0) {
      obj.status = lobbyStateMessage_LobbyStatusToJSON(message.status);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => LobbyPlayer.toJSON(e));
    }
    if (message.settings !== undefined) {
      obj.settings = GalaxyGenerateSettings.toJSON(message.settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LobbyStateMessage>, I>>(base?: I): LobbyStateMessage {
    return LobbyStateMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LobbyStateMessage>, I>>(object: I): LobbyStateMessage {
    const message = createBaseLobbyStateMessage();
    message.sessionId = object.sessionId ?? "";
    message.inviteCode = object.inviteCode ?? "";
    message.hostPlayerId = object.hostPlayerId ?? "";
    message.status = object.status ?? 0;
    message.players = object.players?.map((e) => LobbyPlayer.fromPartial(e)) || [];
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? GalaxyGenerateSettings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseLobbyPlayer(): LobbyPlayer {
  return { playerId: "", displayName: "", color: "", isReady: false, isHost: false, isConnected: false, joinedAt: 0 };
}

export const LobbyPlayer: MessageFns<LobbyPlayer> = {
  encode(message: LobbyPlayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerId !== "") {
      writer.uint32(10).string(message.playerId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.color !== "") {
      writer.uint32(26).string(message.color);
    }
    if (message.isReady !== false) {
      writer.uint32(32).bool(message.isReady);
    }
    if (message.isHost !== false) {
      writer.uint32(40).bool(message.isHost);
    }
    if (message.isConnected !== false) {
      writer.uint32(48).bool(message.isConnected);
    }
    if (message.joinedAt !== 0) {
      writer.uint32(56).int64(message.joinedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LobbyPlayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLobbyPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isReady = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isHost = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isConnected = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.joinedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LobbyPlayer {
    return {
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      isReady: isSet(object.isReady) ? globalThis.Boolean(object.isReady) : false,
      isHost: isSet(object.isHost) ? globalThis.Boolean(object.isHost) : false,
      isConnected: isSet(object.isConnected) ? globalThis.Boolean(object.isConnected) : false,
      joinedAt: isSet(object.joinedAt) ? globalThis.Number(object.joinedAt) : 0,
    };
  },

  toJSON(message: LobbyPlayer): unknown {
    const obj: any = {};
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.isReady !== false) {
      obj.isReady = message.isReady;
    }
    if (message.isHost !== false) {
      obj.isHost = message.isHost;
    }
    if (message.isConnected !== false) {
      obj.isConnected = message.isConnected;
    }
    if (message.joinedAt !== 0) {
      obj.joinedAt = Math.round(message.joinedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LobbyPlayer>, I>>(base?: I): LobbyPlayer {
    return LobbyPlayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LobbyPlayer>, I>>(object: I): LobbyPlayer {
    const message = createBaseLobbyPlayer();
    message.playerId = object.playerId ?? "";
    message.displayName = object.displayName ?? "";
    message.color = object.color ?? "";
    message.isReady = object.isReady ?? false;
    message.isHost = object.isHost ?? false;
    message.isConnected = object.isConnected ?? false;
    message.joinedAt = object.joinedAt ?? 0;
    return message;
  },
};

function createBasePlayerJoinedMessage(): PlayerJoinedMessage {
  return { player: undefined };
}

export const PlayerJoinedMessage: MessageFns<PlayerJoinedMessage> = {
  encode(message: PlayerJoinedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.player !== undefined) {
      LobbyPlayer.encode(message.player, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerJoinedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerJoinedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.player = LobbyPlayer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerJoinedMessage {
    return { player: isSet(object.player) ? LobbyPlayer.fromJSON(object.player) : undefined };
  },

  toJSON(message: PlayerJoinedMessage): unknown {
    const obj: any = {};
    if (message.player !== undefined) {
      obj.player = LobbyPlayer.toJSON(message.player);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerJoinedMessage>, I>>(base?: I): PlayerJoinedMessage {
    return PlayerJoinedMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerJoinedMessage>, I>>(object: I): PlayerJoinedMessage {
    const message = createBasePlayerJoinedMessage();
    message.player = (object.player !== undefined && object.player !== null)
      ? LobbyPlayer.fromPartial(object.player)
      : undefined;
    return message;
  },
};

function createBasePlayerLeftMessage(): PlayerLeftMessage {
  return { playerId: "", displayName: "" };
}

export const PlayerLeftMessage: MessageFns<PlayerLeftMessage> = {
  encode(message: PlayerLeftMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerId !== "") {
      writer.uint32(10).string(message.playerId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerLeftMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerLeftMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerLeftMessage {
    return {
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: PlayerLeftMessage): unknown {
    const obj: any = {};
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerLeftMessage>, I>>(base?: I): PlayerLeftMessage {
    return PlayerLeftMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerLeftMessage>, I>>(object: I): PlayerLeftMessage {
    const message = createBasePlayerLeftMessage();
    message.playerId = object.playerId ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBasePlayerUpdatedMessage(): PlayerUpdatedMessage {
  return { player: undefined };
}

export const PlayerUpdatedMessage: MessageFns<PlayerUpdatedMessage> = {
  encode(message: PlayerUpdatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.player !== undefined) {
      LobbyPlayer.encode(message.player, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerUpdatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerUpdatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.player = LobbyPlayer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerUpdatedMessage {
    return { player: isSet(object.player) ? LobbyPlayer.fromJSON(object.player) : undefined };
  },

  toJSON(message: PlayerUpdatedMessage): unknown {
    const obj: any = {};
    if (message.player !== undefined) {
      obj.player = LobbyPlayer.toJSON(message.player);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerUpdatedMessage>, I>>(base?: I): PlayerUpdatedMessage {
    return PlayerUpdatedMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerUpdatedMessage>, I>>(object: I): PlayerUpdatedMessage {
    const message = createBasePlayerUpdatedMessage();
    message.player = (object.player !== undefined && object.player !== null)
      ? LobbyPlayer.fromPartial(object.player)
      : undefined;
    return message;
  },
};

function createBaseLobbySettingsUpdatedMessage(): LobbySettingsUpdatedMessage {
  return { settings: undefined, updatedByPlayerId: "" };
}

export const LobbySettingsUpdatedMessage: MessageFns<LobbySettingsUpdatedMessage> = {
  encode(message: LobbySettingsUpdatedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settings !== undefined) {
      GalaxyGenerateSettings.encode(message.settings, writer.uint32(10).fork()).join();
    }
    if (message.updatedByPlayerId !== "") {
      writer.uint32(18).string(message.updatedByPlayerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LobbySettingsUpdatedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLobbySettingsUpdatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settings = GalaxyGenerateSettings.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedByPlayerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LobbySettingsUpdatedMessage {
    return {
      settings: isSet(object.settings) ? GalaxyGenerateSettings.fromJSON(object.settings) : undefined,
      updatedByPlayerId: isSet(object.updatedByPlayerId) ? globalThis.String(object.updatedByPlayerId) : "",
    };
  },

  toJSON(message: LobbySettingsUpdatedMessage): unknown {
    const obj: any = {};
    if (message.settings !== undefined) {
      obj.settings = GalaxyGenerateSettings.toJSON(message.settings);
    }
    if (message.updatedByPlayerId !== "") {
      obj.updatedByPlayerId = message.updatedByPlayerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LobbySettingsUpdatedMessage>, I>>(base?: I): LobbySettingsUpdatedMessage {
    return LobbySettingsUpdatedMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LobbySettingsUpdatedMessage>, I>>(object: I): LobbySettingsUpdatedMessage {
    const message = createBaseLobbySettingsUpdatedMessage();
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? GalaxyGenerateSettings.fromPartial(object.settings)
      : undefined;
    message.updatedByPlayerId = object.updatedByPlayerId ?? "";
    return message;
  },
};

function createBaseGameStartingMessage(): GameStartingMessage {
  return { finalSettings: undefined, startTime: 0 };
}

export const GameStartingMessage: MessageFns<GameStartingMessage> = {
  encode(message: GameStartingMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalSettings !== undefined) {
      GalaxyGenerateSettings.encode(message.finalSettings, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== 0) {
      writer.uint32(16).int64(message.startTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameStartingMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameStartingMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalSettings = GalaxyGenerateSettings.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameStartingMessage {
    return {
      finalSettings: isSet(object.finalSettings) ? GalaxyGenerateSettings.fromJSON(object.finalSettings) : undefined,
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
    };
  },

  toJSON(message: GameStartingMessage): unknown {
    const obj: any = {};
    if (message.finalSettings !== undefined) {
      obj.finalSettings = GalaxyGenerateSettings.toJSON(message.finalSettings);
    }
    if (message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameStartingMessage>, I>>(base?: I): GameStartingMessage {
    return GameStartingMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameStartingMessage>, I>>(object: I): GameStartingMessage {
    const message = createBaseGameStartingMessage();
    message.finalSettings = (object.finalSettings !== undefined && object.finalSettings !== null)
      ? GalaxyGenerateSettings.fromPartial(object.finalSettings)
      : undefined;
    message.startTime = object.startTime ?? 0;
    return message;
  },
};

function createBaseGameLoadingMessage(): GameLoadingMessage {
  return { progress: 0, statusText: "", phase: "" };
}

export const GameLoadingMessage: MessageFns<GameLoadingMessage> = {
  encode(message: GameLoadingMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.progress !== 0) {
      writer.uint32(13).float(message.progress);
    }
    if (message.statusText !== "") {
      writer.uint32(18).string(message.statusText);
    }
    if (message.phase !== "") {
      writer.uint32(26).string(message.phase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameLoadingMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameLoadingMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.progress = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statusText = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phase = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameLoadingMessage {
    return {
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
      statusText: isSet(object.statusText) ? globalThis.String(object.statusText) : "",
      phase: isSet(object.phase) ? globalThis.String(object.phase) : "",
    };
  },

  toJSON(message: GameLoadingMessage): unknown {
    const obj: any = {};
    if (message.progress !== 0) {
      obj.progress = message.progress;
    }
    if (message.statusText !== "") {
      obj.statusText = message.statusText;
    }
    if (message.phase !== "") {
      obj.phase = message.phase;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameLoadingMessage>, I>>(base?: I): GameLoadingMessage {
    return GameLoadingMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameLoadingMessage>, I>>(object: I): GameLoadingMessage {
    const message = createBaseGameLoadingMessage();
    message.progress = object.progress ?? 0;
    message.statusText = object.statusText ?? "";
    message.phase = object.phase ?? "";
    return message;
  },
};

function createBaseGameMessage(): GameMessage {
  return { gameState: undefined, gameEvent: undefined, turnUpdate: undefined };
}

export const GameMessage: MessageFns<GameMessage> = {
  encode(message: GameMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameState !== undefined) {
      GameStateMessage.encode(message.gameState, writer.uint32(10).fork()).join();
    }
    if (message.gameEvent !== undefined) {
      GameEventMessage.encode(message.gameEvent, writer.uint32(18).fork()).join();
    }
    if (message.turnUpdate !== undefined) {
      TurnUpdateMessage.encode(message.turnUpdate, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gameState = GameStateMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gameEvent = GameEventMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.turnUpdate = TurnUpdateMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameMessage {
    return {
      gameState: isSet(object.gameState) ? GameStateMessage.fromJSON(object.gameState) : undefined,
      gameEvent: isSet(object.gameEvent) ? GameEventMessage.fromJSON(object.gameEvent) : undefined,
      turnUpdate: isSet(object.turnUpdate) ? TurnUpdateMessage.fromJSON(object.turnUpdate) : undefined,
    };
  },

  toJSON(message: GameMessage): unknown {
    const obj: any = {};
    if (message.gameState !== undefined) {
      obj.gameState = GameStateMessage.toJSON(message.gameState);
    }
    if (message.gameEvent !== undefined) {
      obj.gameEvent = GameEventMessage.toJSON(message.gameEvent);
    }
    if (message.turnUpdate !== undefined) {
      obj.turnUpdate = TurnUpdateMessage.toJSON(message.turnUpdate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameMessage>, I>>(base?: I): GameMessage {
    return GameMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameMessage>, I>>(object: I): GameMessage {
    const message = createBaseGameMessage();
    message.gameState = (object.gameState !== undefined && object.gameState !== null)
      ? GameStateMessage.fromPartial(object.gameState)
      : undefined;
    message.gameEvent = (object.gameEvent !== undefined && object.gameEvent !== null)
      ? GameEventMessage.fromPartial(object.gameEvent)
      : undefined;
    message.turnUpdate = (object.turnUpdate !== undefined && object.turnUpdate !== null)
      ? TurnUpdateMessage.fromPartial(object.turnUpdate)
      : undefined;
    return message;
  },
};

function createBaseGameStateMessage(): GameStateMessage {
  return { stateData: "", turnNumber: 0, gameTime: 0 };
}

export const GameStateMessage: MessageFns<GameStateMessage> = {
  encode(message: GameStateMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stateData !== "") {
      writer.uint32(10).string(message.stateData);
    }
    if (message.turnNumber !== 0) {
      writer.uint32(16).int64(message.turnNumber);
    }
    if (message.gameTime !== 0) {
      writer.uint32(24).int64(message.gameTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameStateMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameStateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stateData = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.turnNumber = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gameTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameStateMessage {
    return {
      stateData: isSet(object.stateData) ? globalThis.String(object.stateData) : "",
      turnNumber: isSet(object.turnNumber) ? globalThis.Number(object.turnNumber) : 0,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
    };
  },

  toJSON(message: GameStateMessage): unknown {
    const obj: any = {};
    if (message.stateData !== "") {
      obj.stateData = message.stateData;
    }
    if (message.turnNumber !== 0) {
      obj.turnNumber = Math.round(message.turnNumber);
    }
    if (message.gameTime !== 0) {
      obj.gameTime = Math.round(message.gameTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameStateMessage>, I>>(base?: I): GameStateMessage {
    return GameStateMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameStateMessage>, I>>(object: I): GameStateMessage {
    const message = createBaseGameStateMessage();
    message.stateData = object.stateData ?? "";
    message.turnNumber = object.turnNumber ?? 0;
    message.gameTime = object.gameTime ?? 0;
    return message;
  },
};

function createBaseGameEventMessage(): GameEventMessage {
  return { eventType: "", eventData: "", affectedPlayers: [] };
}

export const GameEventMessage: MessageFns<GameEventMessage> = {
  encode(message: GameEventMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== "") {
      writer.uint32(10).string(message.eventType);
    }
    if (message.eventData !== "") {
      writer.uint32(18).string(message.eventData);
    }
    for (const v of message.affectedPlayers) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameEventMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameEventMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventData = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.affectedPlayers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameEventMessage {
    return {
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      eventData: isSet(object.eventData) ? globalThis.String(object.eventData) : "",
      affectedPlayers: globalThis.Array.isArray(object?.affectedPlayers)
        ? object.affectedPlayers.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GameEventMessage): unknown {
    const obj: any = {};
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.eventData !== "") {
      obj.eventData = message.eventData;
    }
    if (message.affectedPlayers?.length) {
      obj.affectedPlayers = message.affectedPlayers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameEventMessage>, I>>(base?: I): GameEventMessage {
    return GameEventMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameEventMessage>, I>>(object: I): GameEventMessage {
    const message = createBaseGameEventMessage();
    message.eventType = object.eventType ?? "";
    message.eventData = object.eventData ?? "";
    message.affectedPlayers = object.affectedPlayers?.map((e) => e) || [];
    return message;
  },
};

function createBaseTurnUpdateMessage(): TurnUpdateMessage {
  return { turnNumber: 0, turnDeadline: 0, isPaused: false };
}

export const TurnUpdateMessage: MessageFns<TurnUpdateMessage> = {
  encode(message: TurnUpdateMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.turnNumber !== 0) {
      writer.uint32(8).int64(message.turnNumber);
    }
    if (message.turnDeadline !== 0) {
      writer.uint32(16).int64(message.turnDeadline);
    }
    if (message.isPaused !== false) {
      writer.uint32(24).bool(message.isPaused);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TurnUpdateMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTurnUpdateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.turnNumber = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.turnDeadline = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isPaused = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TurnUpdateMessage {
    return {
      turnNumber: isSet(object.turnNumber) ? globalThis.Number(object.turnNumber) : 0,
      turnDeadline: isSet(object.turnDeadline) ? globalThis.Number(object.turnDeadline) : 0,
      isPaused: isSet(object.isPaused) ? globalThis.Boolean(object.isPaused) : false,
    };
  },

  toJSON(message: TurnUpdateMessage): unknown {
    const obj: any = {};
    if (message.turnNumber !== 0) {
      obj.turnNumber = Math.round(message.turnNumber);
    }
    if (message.turnDeadline !== 0) {
      obj.turnDeadline = Math.round(message.turnDeadline);
    }
    if (message.isPaused !== false) {
      obj.isPaused = message.isPaused;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TurnUpdateMessage>, I>>(base?: I): TurnUpdateMessage {
    return TurnUpdateMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TurnUpdateMessage>, I>>(object: I): TurnUpdateMessage {
    const message = createBaseTurnUpdateMessage();
    message.turnNumber = object.turnNumber ?? 0;
    message.turnDeadline = object.turnDeadline ?? 0;
    message.isPaused = object.isPaused ?? false;
    return message;
  },
};

function createBaseChatMessage(): ChatMessage {
  return {
    senderId: "",
    senderDisplayName: "",
    timestamp: 0,
    global: undefined,
    private: undefined,
    lobby: undefined,
    system: undefined,
  };
}

export const ChatMessage: MessageFns<ChatMessage> = {
  encode(message: ChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.senderId !== "") {
      writer.uint32(10).string(message.senderId);
    }
    if (message.senderDisplayName !== "") {
      writer.uint32(18).string(message.senderDisplayName);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    if (message.global !== undefined) {
      GlobalChatMessage.encode(message.global, writer.uint32(82).fork()).join();
    }
    if (message.private !== undefined) {
      PrivateChatMessage.encode(message.private, writer.uint32(90).fork()).join();
    }
    if (message.lobby !== undefined) {
      LobbyChatMessage.encode(message.lobby, writer.uint32(98).fork()).join();
    }
    if (message.system !== undefined) {
      SystemChatMessage.encode(message.system, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.senderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderDisplayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.global = GlobalChatMessage.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.private = PrivateChatMessage.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.lobby = LobbyChatMessage.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.system = SystemChatMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage {
    return {
      senderId: isSet(object.senderId) ? globalThis.String(object.senderId) : "",
      senderDisplayName: isSet(object.senderDisplayName) ? globalThis.String(object.senderDisplayName) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      global: isSet(object.global) ? GlobalChatMessage.fromJSON(object.global) : undefined,
      private: isSet(object.private) ? PrivateChatMessage.fromJSON(object.private) : undefined,
      lobby: isSet(object.lobby) ? LobbyChatMessage.fromJSON(object.lobby) : undefined,
      system: isSet(object.system) ? SystemChatMessage.fromJSON(object.system) : undefined,
    };
  },

  toJSON(message: ChatMessage): unknown {
    const obj: any = {};
    if (message.senderId !== "") {
      obj.senderId = message.senderId;
    }
    if (message.senderDisplayName !== "") {
      obj.senderDisplayName = message.senderDisplayName;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.global !== undefined) {
      obj.global = GlobalChatMessage.toJSON(message.global);
    }
    if (message.private !== undefined) {
      obj.private = PrivateChatMessage.toJSON(message.private);
    }
    if (message.lobby !== undefined) {
      obj.lobby = LobbyChatMessage.toJSON(message.lobby);
    }
    if (message.system !== undefined) {
      obj.system = SystemChatMessage.toJSON(message.system);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage>, I>>(base?: I): ChatMessage {
    return ChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage>, I>>(object: I): ChatMessage {
    const message = createBaseChatMessage();
    message.senderId = object.senderId ?? "";
    message.senderDisplayName = object.senderDisplayName ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.global = (object.global !== undefined && object.global !== null)
      ? GlobalChatMessage.fromPartial(object.global)
      : undefined;
    message.private = (object.private !== undefined && object.private !== null)
      ? PrivateChatMessage.fromPartial(object.private)
      : undefined;
    message.lobby = (object.lobby !== undefined && object.lobby !== null)
      ? LobbyChatMessage.fromPartial(object.lobby)
      : undefined;
    message.system = (object.system !== undefined && object.system !== null)
      ? SystemChatMessage.fromPartial(object.system)
      : undefined;
    return message;
  },
};

function createBaseGlobalChatMessage(): GlobalChatMessage {
  return { message: "" };
}

export const GlobalChatMessage: MessageFns<GlobalChatMessage> = {
  encode(message: GlobalChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GlobalChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGlobalChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GlobalChatMessage {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: GlobalChatMessage): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GlobalChatMessage>, I>>(base?: I): GlobalChatMessage {
    return GlobalChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GlobalChatMessage>, I>>(object: I): GlobalChatMessage {
    const message = createBaseGlobalChatMessage();
    message.message = object.message ?? "";
    return message;
  },
};

function createBasePrivateChatMessage(): PrivateChatMessage {
  return { recipientId: "", message: "" };
}

export const PrivateChatMessage: MessageFns<PrivateChatMessage> = {
  encode(message: PrivateChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recipientId !== "") {
      writer.uint32(10).string(message.recipientId);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recipientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateChatMessage {
    return {
      recipientId: isSet(object.recipientId) ? globalThis.String(object.recipientId) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: PrivateChatMessage): unknown {
    const obj: any = {};
    if (message.recipientId !== "") {
      obj.recipientId = message.recipientId;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrivateChatMessage>, I>>(base?: I): PrivateChatMessage {
    return PrivateChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrivateChatMessage>, I>>(object: I): PrivateChatMessage {
    const message = createBasePrivateChatMessage();
    message.recipientId = object.recipientId ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseLobbyChatMessage(): LobbyChatMessage {
  return { message: "" };
}

export const LobbyChatMessage: MessageFns<LobbyChatMessage> = {
  encode(message: LobbyChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LobbyChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLobbyChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LobbyChatMessage {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: LobbyChatMessage): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LobbyChatMessage>, I>>(base?: I): LobbyChatMessage {
    return LobbyChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LobbyChatMessage>, I>>(object: I): LobbyChatMessage {
    const message = createBaseLobbyChatMessage();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseSystemChatMessage(): SystemChatMessage {
  return { message: "", messageType: "" };
}

export const SystemChatMessage: MessageFns<SystemChatMessage> = {
  encode(message: SystemChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.messageType !== "") {
      writer.uint32(18).string(message.messageType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemChatMessage {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      messageType: isSet(object.messageType) ? globalThis.String(object.messageType) : "",
    };
  },

  toJSON(message: SystemChatMessage): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.messageType !== "") {
      obj.messageType = message.messageType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemChatMessage>, I>>(base?: I): SystemChatMessage {
    return SystemChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemChatMessage>, I>>(object: I): SystemChatMessage {
    const message = createBaseSystemChatMessage();
    message.message = object.message ?? "";
    message.messageType = object.messageType ?? "";
    return message;
  },
};

function createBaseSystemMessage(): SystemMessage {
  return { connection: undefined, auth: undefined, serverStatus: undefined };
}

export const SystemMessage: MessageFns<SystemMessage> = {
  encode(message: SystemMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connection !== undefined) {
      ConnectionMessage.encode(message.connection, writer.uint32(10).fork()).join();
    }
    if (message.auth !== undefined) {
      AuthMessage.encode(message.auth, writer.uint32(18).fork()).join();
    }
    if (message.serverStatus !== undefined) {
      ServerStatusMessage.encode(message.serverStatus, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connection = ConnectionMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.auth = AuthMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serverStatus = ServerStatusMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMessage {
    return {
      connection: isSet(object.connection) ? ConnectionMessage.fromJSON(object.connection) : undefined,
      auth: isSet(object.auth) ? AuthMessage.fromJSON(object.auth) : undefined,
      serverStatus: isSet(object.serverStatus) ? ServerStatusMessage.fromJSON(object.serverStatus) : undefined,
    };
  },

  toJSON(message: SystemMessage): unknown {
    const obj: any = {};
    if (message.connection !== undefined) {
      obj.connection = ConnectionMessage.toJSON(message.connection);
    }
    if (message.auth !== undefined) {
      obj.auth = AuthMessage.toJSON(message.auth);
    }
    if (message.serverStatus !== undefined) {
      obj.serverStatus = ServerStatusMessage.toJSON(message.serverStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemMessage>, I>>(base?: I): SystemMessage {
    return SystemMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemMessage>, I>>(object: I): SystemMessage {
    const message = createBaseSystemMessage();
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? ConnectionMessage.fromPartial(object.connection)
      : undefined;
    message.auth = (object.auth !== undefined && object.auth !== null)
      ? AuthMessage.fromPartial(object.auth)
      : undefined;
    message.serverStatus = (object.serverStatus !== undefined && object.serverStatus !== null)
      ? ServerStatusMessage.fromPartial(object.serverStatus)
      : undefined;
    return message;
  },
};

function createBaseConnectionMessage(): ConnectionMessage {
  return { status: "", reason: "" };
}

export const ConnectionMessage: MessageFns<ConnectionMessage> = {
  encode(message: ConnectionMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionMessage {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: ConnectionMessage): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionMessage>, I>>(base?: I): ConnectionMessage {
    return ConnectionMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionMessage>, I>>(object: I): ConnectionMessage {
    const message = createBaseConnectionMessage();
    message.status = object.status ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseAuthMessage(): AuthMessage {
  return { status: "", message: "" };
}

export const AuthMessage: MessageFns<AuthMessage> = {
  encode(message: AuthMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthMessage {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: AuthMessage): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthMessage>, I>>(base?: I): AuthMessage {
    return AuthMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthMessage>, I>>(object: I): AuthMessage {
    const message = createBaseAuthMessage();
    message.status = object.status ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseServerStatusMessage(): ServerStatusMessage {
  return { isMaintenance: false, version: "", playerCount: 0 };
}

export const ServerStatusMessage: MessageFns<ServerStatusMessage> = {
  encode(message: ServerStatusMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isMaintenance !== false) {
      writer.uint32(8).bool(message.isMaintenance);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.playerCount !== 0) {
      writer.uint32(24).int32(message.playerCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerStatusMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerStatusMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isMaintenance = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.playerCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerStatusMessage {
    return {
      isMaintenance: isSet(object.isMaintenance) ? globalThis.Boolean(object.isMaintenance) : false,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      playerCount: isSet(object.playerCount) ? globalThis.Number(object.playerCount) : 0,
    };
  },

  toJSON(message: ServerStatusMessage): unknown {
    const obj: any = {};
    if (message.isMaintenance !== false) {
      obj.isMaintenance = message.isMaintenance;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.playerCount !== 0) {
      obj.playerCount = Math.round(message.playerCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerStatusMessage>, I>>(base?: I): ServerStatusMessage {
    return ServerStatusMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerStatusMessage>, I>>(object: I): ServerStatusMessage {
    const message = createBaseServerStatusMessage();
    message.isMaintenance = object.isMaintenance ?? false;
    message.version = object.version ?? "";
    message.playerCount = object.playerCount ?? 0;
    return message;
  },
};

function createBaseErrorMessage(): ErrorMessage {
  return { errorCode: "", errorMessage: "", context: "", details: [] };
}

export const ErrorMessage: MessageFns<ErrorMessage> = {
  encode(message: ErrorMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    for (const v of message.details) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.details.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorMessage {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      details: globalThis.Array.isArray(object?.details) ? object.details.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ErrorMessage): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.details?.length) {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorMessage>, I>>(base?: I): ErrorMessage {
    return ErrorMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorMessage>, I>>(object: I): ErrorMessage {
    const message = createBaseErrorMessage();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.context = object.context ?? "";
    message.details = object.details?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
